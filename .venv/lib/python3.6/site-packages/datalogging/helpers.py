import stackprinter
import threading
import subprocess
import atexit
import logging
from io import BytesIO

import numpy as np


JPEG_LIB = 'PIL'
# Compressing with Pillow took around 12ms on my macbook for a
# 500x500 image at 80% quality, compared to around 7ms with openCV.
# Maybe Pillow would be faster if it was built from source with
# libjpeg-turbo? Still, I know Pillow is already available in our
# box environment, so we'll use that for now.

if JPEG_LIB == 'PIL':
    from PIL import Image
    def compress_image(image, quality):
        img = Image.fromarray(image)
        bytestream = BytesIO()
        img.save(bytestream, format='JPEG', quality=quality)
        bytestream.seek(0)
        bytes_val = bytestream.read()
        return bytes_val

    def decompress_image(val):
        return np.array(Image.open(BytesIO(val)))

elif JPEG_LIB == 'OpenCV':
    def compress_image(image, quality):
        _, encoded = cv2.imencode('.jpg', image, (cv2.IMWRITE_JPEG_QUALITY, quality))
        bytes_val = encoded.tobytes()
        return bytes_val

    def decompress_image(bytes_val):
        arr = np.fromstring(bytes_val, dtype='uint8')
        img = cv2.imdecode(arr, 1)
        return img

elif JPEG_LIB is None:
    logging.getLogger('system').warning("jpeg compression won't be available, "
                                        "needs Pillow or opencv-python")
    def compress_image(*_, **__):
        raise Exception("Cannot use jpeg compression, "
                        "need to install Pillow or opencv-python")
    decompress_image = compress_image


def is_compressible(value):
    return (isinstance(value, np.ndarray)
            and value.dtype == 'uint8'
            and value.ndim in [2,3]
            and np.product(value.shape) > 256)

def compress(rec):
    quality = rec.get('image_quality', None)
    if quality is None:
        return rec

    data = rec['data']

    if is_compressible(data):
        rec['data'] = compress_image(data, quality)
    elif isinstance(data, list):
        rec['data'] = [(compress_image(val, quality) if is_compressible(val) else val)
                      for val in data]
    elif isinstance(data, dict):
        for key, val in data.items():
            if is_compressible(val):
                data[key] = compress_image(val, quality)
    return rec

def decompress(rec):
    quality = rec.get('image_quality', None)
    if quality is None:
        return rec
    else:
        data = rec['data']
        if isinstance(data, bytes):
            rec['data'] = decompress_image(data)
        elif isinstance(data, list):
            rec['data'] = [(decompress_image(val) if isinstance(val, bytes) else val)
                           for val in data]
        elif isinstance(data, dict):
            for key, val in data.items():
                if isinstance(val, bytes):
                    data[key] = decompress_image(val)
    return rec


def start_listener(module_path='datalogging.lineplot',
                   port=15001, extra_args=[]):
    """
    Start a plot listener process
    """
    logger = logging.getLogger('system')
    command = ["python", "-m", module_path, str(port)]
    command.extend(extra_args)

    listener_process = subprocess.Popen(command)

    lst_string = "'%s', pid %s" % (" ".join(listener_process.args),
                                   listener_process.pid)
    logger.info("Started listener " + lst_string)

    def stopit():
        logger = logging.getLogger('system')
        logger.debug("Stopping listener " + lst_string)
        listener_process.kill()
        listener_process.wait()
        logger.debug("listener stopped")

    atexit.register(stopit)
    return listener_process


class TracebackThread(threading.Thread):
    """
    Thread with more informative tracebacks

    compare usage of traceback.format_exc in threading.Thread
    """
    def run(self):
        try:
            super().run()
        except:
            stackprinter.show()
