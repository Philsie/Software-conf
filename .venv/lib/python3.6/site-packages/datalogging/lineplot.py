"""
Listen for timestamped numpy arrays on a given port and plot lines

This module can be executed as a script: Provide the adress and port where it should
listen and it will listen forever.

"""

import sys
import numpy as np

from matplotlib import pyplot as plt
from matplotlib.widgets import Button, TextBox  # requires matplotlib > 2.1
import matplotlib.dates as mdates

from datalogging.plotting_base import MatplotlibListener


def stack_arrays(arrays):
    try:
        return np.stack(arrays, axis=0)
    except ValueError as e:
        raise ValueError("Dimensionality seems to have changed. Can't cope with"
                         " that yet, please restart plotter") from e


class Lineplot(MatplotlibListener):

    def prepare_data(self, data, timestamps, messages, steps):
        """
        This Listener assumes that the payload of each log call is either
        a 1D array, a scalar, or a tuple of column headers and a 1D array
        such as `(['label1', 'label2', 'label3'], array)`
        """
        latest_msg = messages[-1]
        latest_step = steps[-1]
        history = data
        lastframe = history[-1]
        if isinstance(lastframe, (np.ndarray, np.generic)):
            # we accept arrays or numpy scalar types
            timeseries = stack_arrays(history) * 1  # *1 ensures bools become numbers
            if lastframe.ndim > 0:
                column_names = ['%d' % dim for dim in range(lastframe.shape[-1])]
            else:
                column_names = [' ']
        elif isinstance(lastframe, tuple):
            # ...or arrays and column headers, for labeling
            if isinstance(lastframe[0], np.ndarray):
                frames = [frame for frame, names in history]
                timeseries = stack_arrays(frames) * 1
                column_names = lastframe[1]
            elif isinstance(lastframe[1], np.ndarray):
                frames = [frame for names, frame in history]
                timeseries = stack_arrays(frames) * 1
                column_names = lastframe[0]
            else:
                raise ValueError("Expected a tuple of an array and a "
                                 "list of strings")
        elif isinstance(lastframe, (int, float)):
            # ... or python numbers
            timeseries = np.array(history)
            column_names = [' ']
        else:
            raise ValueError("Expected a number, an array or a tuple of"
                             " an array and its list of column names")

        if timeseries.ndim == 1:
            timeseries = timeseries.reshape(-1,1)

        return timestamps, timeseries, column_names, latest_msg, latest_step

    def create_figure(self, timestamps, timeseries, column_names, latest_msg, latest_step):
        self.paused = False
        self.lines = []
        self.buttons = []
        self.manual_ylims = None
        self.xticks = 'auto'

        figure = plt.figure(figsize=(10,5))
        if figure.canvas.manager is not None:
            figure.canvas.manager.set_window_title(latest_msg)
        self.ax = plt.axes([0.02, 0.13, 0.88, 0.79])
        self.ax.grid(True, which='major')

        self.ax.yaxis.tick_right()

        # get a zero line
        self.ax.axhline(0, color='0.8', linewidth=1.5)

        # make the plot lines & give them some on/off toggles
        for dim in range(timeseries.shape[1]):
            line, = self.ax.plot(timestamps,
                                 timeseries[:, dim],
                                 '.-',
                                 label=column_names[dim])
            self.lines.append(line)

        # create a legend
        leg = self.ax.legend(loc='upper left')

        # allow toggling lines on/off by clicking them in the legend
        line_picker_map = dict()
        for legend_line, real_line in zip(leg.get_lines(), self.lines):
            legend_line.set_picker(7)
            line_picker_map[legend_line] = real_line

        def onpick(event):
            picked_line = event.artist
            line = line_picker_map[picked_line]
            vis = not line.get_visible()
            line.set_visible(vis)

            if vis:
                picked_line.set_alpha(1.0)
            else:
                picked_line.set_alpha(0.2)

        figure.canvas.mpl_connect('pick_event', onpick)

        # give a hover to the legend lines
        leglines = leg.get_lines()
        lwidth = leglines[0].get_linewidth()
        def on_hover(event):
            for lline in leglines:
                contains, _ = lline.contains(event)
                if contains:
                    lline.set_linewidth(lwidth * 2)
                else:
                    lline.set_linewidth(lwidth)

        figure.canvas.mpl_connect('motion_notify_event', on_hover)

        # add a pause button
        paus_bt_ax = plt.axes([0.85, 0.94, 0.09, 0.05])
        pause_button = Button(paus_bt_ax, 'pause', color='0.1', hovercolor='0.2')

        def toggle_pause(event, button=pause_button):
            self.paused = not self.paused
            button.label.set_text('continue' if self.paused else 'pause')

        pause_button.on_clicked(toggle_pause)
        self.buttons.append(pause_button)

        # add a text box to allow manual ylim override
        def set_ylim(text):
            if text and text != 'auto':
                ymin, ymax = [float(v) for v in text.split(',')]
                self.ax.set_ylim(ymin, ymax)
                self.manual_ylims = (ymin, ymax)
            else:
                self.manual_ylims = None

        ylim_textbox_ax = plt.axes([0.85, 0.01, 0.1, 0.05])
        ylim_textbox = TextBox(ylim_textbox_ax, 'ylim ',  initial='auto', color='0.2',  hovercolor='0.4')
        ylim_textbox.on_submit(set_ylim)
        self.ylim_textbox = ylim_textbox

        # add a text box for manual override of the history window length
        def set_xhist(text):
            if text:
                self.len_history = int(text)

        xhist_textbox_ax = plt.axes([0.44, 0.01, 0.1, 0.05])
        xhist_textbox = TextBox(xhist_textbox_ax, 'history (steps) ',
                                initial=str(self.len_history), color='0.2', hovercolor='0.4')
        xhist_textbox.on_submit(set_xhist)
        self.xhist_textbox = xhist_textbox

        # add a toggle whether to force an x axis tick on each second
        self.apply_xtick_settings()
        def toggle_ticks(event):
            if self.xticks == 'seconds':
                self.xticks = 'auto'
            elif self.xticks == 'auto':
                self.xticks = 'seconds'
            self.apply_xtick_settings()
            self.xticks_button.label.set_text('using %s grid' % self.xticks)

        ticks_bt_ax = plt.axes([0.03, 0.01, 0.14, 0.05])
        ticks_button = Button(ticks_bt_ax, 'using %s grid' % self.xticks, color='0.1', hovercolor='0.2')
        ticks_button.on_clicked(toggle_ticks)
        self.xticks_button = ticks_button

        return figure

    def update_figure(self, figure, timestamps, timeseries, column_names, latest_msg, latest_step):
        # Only plot if there's already enough data to set x axis limits
        if len(timestamps) < 2:
            return

        title = latest_msg
        if latest_step is not None:
            title += " [%s]" % latest_step

        if not self.paused:
            plt.suptitle(title)

            for dim in range(timeseries.shape[1]):
                line = self.lines[dim]
                line.set_xdata(timestamps)
                line.set_ydata(timeseries[:, dim])

            xmin = min(timestamps[-self.len_history:])
            xmax = max(timestamps[-self.len_history:])

            if len(timestamps) < self.len_history:
                # ensure a stable x axis scale even when
                # the buffer isn't full yet
                diff = timestamps[1] - timestamps[0]
                xmin = xmin - diff * (self.len_history - len(timestamps))

            self.ax.set_xlim(xmin, xmax)
            self.ax.margins(x=0.1)
            figure.autofmt_xdate()

            # figure out the y axis limits
            if self.manual_ylims:
                self.ax.set_ylim(*self.manual_ylims)
            else:
                is_visible = np.array([ln.get_visible() for ln in self.lines])
                if np.any(is_visible):
                    # find data limits of only the visible dimensions, ignoring nans
                    ymin = np.nanmin(timeseries[-int(self.len_history*1.5):, is_visible])
                    ymax = np.nanmax(timeseries[-int(self.len_history*1.5):, is_visible])

                    ymin = np.nan_to_num(ymin) # if lims are still nan, it means that
                    ymax = np.nan_to_num(ymax) # the whole buffer was nan -> use lim 0.

                    # prevent crazy jumpy drawing artifacts when data is approx. zero
                    if (ymax - ymin) < 1e-10:
                        mid = (ymax + ymin) / 2
                        ymin, ymax = (mid - 5e-11, mid + 5e-11)

                    # add extra margin because it looks nice
                    span = ymax - ymin
                    margin = span * 0.05
                    self.ax.set_ylim(ymin - margin, ymax + margin)

    def apply_xtick_settings(self):
        if self.xticks == 'auto':
            loc = mdates.AutoDateLocator()
            time_fmt = mdates.AutoDateFormatter(loc)
            self.ax.xaxis.set_major_formatter(time_fmt)
            self.ax.xaxis.set_major_locator(loc)
        elif self.xticks == 'seconds':
            time_fmt = mdates.DateFormatter('%M:%S')
            self.ax.xaxis.set_major_formatter(time_fmt)
            self.ax.xaxis.set_major_locator(mdates.SecondLocator())


if __name__ == '__main__':
    import stackprinter
    stackprinter.set_excepthook(style='darkbg2',
                                suppressed_paths=[r"site-packages/numpy",
                                                  r"site-packages/matplotlib",
                                                  r"lib/python.*/runpy.py"])

    try:
        port = int(sys.argv[1])
    except Exception as e:
        print(e)
        print('\nUsage example:\n"python lineplot.py 15001"')
    else:
        plotter = Lineplot(port=port, len_history=200)
        plotter.start()