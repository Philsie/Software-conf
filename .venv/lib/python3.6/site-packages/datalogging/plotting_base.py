"""
Useful base classes to build asynchronous plotters with,
i.e. plotters that continuosly accept data in the background,
even while they're busy running super slow plot code.

Basic design: Have one thread that just reads from the
network and stores the data in a ring buffer, then draw
plots occasionally on the main thread. Thus the slow
plot code won't block us from reading network packets,
so the queue wont fill up so badly. And conversely the
plot GUI stays responsive even when no packets arrive.

"""

import time
import os
import threading

from datalogging.helpers import TracebackThread
import logging

import numpy as np
import stackprinter
import matplotlib
from matplotlib import pyplot as plt

from datalogging.core import DataLogListener

mpl_stylesheet_path = os.path.join(os.path.dirname(__file__), 'dark.mplstyle')
plt.style.use(mpl_stylesheet_path)
plt.ion()


class DataAccumulator(DataLogListener):

    def __init__(self, port, host, max_buffer=200):
        self.bad_data_change = False
        self.tb_message = None
        self.buffers = None
        self.last_update = -9000
        self.max_buffer = max_buffer
        self.lock = threading.RLock()
        self.logger = logging.getLogger('system')
        self.last_step_seen = 1e10
        super().__init__(port=port, host=host)

    def handler(self, log_obj):
        data = log_obj['data']
        msg = log_obj['msg']
        step = log_obj['step']
        timestamp = log_obj['timestamp']

        if step and isinstance(step, int):
            diff = step - self.last_step_seen
            if diff > 1:
                self.logger.info('Data listener missed %s step(s)' % (diff - 1))

            self.last_step_seen = step

        with self.lock:
            try:
                self._update_buffers(timestamps=timestamp, data=data, messages=msg, steps=step)
            except AssertionError:
                self.interrupt()
                self.purge()
                self.tb_message = stackprinter.format()
                self.bad_data_change = True

        self.last_update = time.perf_counter()

    def _update_buffers(self, **data):
        """ Save the new value and roll buffer """
        if self.buffers is None:
            self.buffers = {key: list() for key in data}

        assert set(self.buffers.keys()) == set(data.keys())

        for name in self.buffers:
            val = data[name]
            buf = self.buffers[name]
            if buf:
                previous_value = buf[-1]
                assert type(val) == type(previous_value), "Type changed"
                if isinstance(val, np.ndarray):
                    assert val.shape == previous_value.shape, "Data shape changed"
            # store this value and delete old ones
            buf.append(val)
            self.buffers[name] = self.buffers[name][-self.max_buffer:]

    def purge(self):
        with self.lock:
            self.buffers = None

    def set_buffersize(self, size):
        with self.lock:
            self.max_buffer = size

    def get_copy(self):
        """
        Get a semi-deep copy of the data collected so far.

        The buffer is a dict of lists of stuff. This method
        produces a copy of the dict and lists, but not of the stuff.
        So even though this listener may continue to collect new data,
        the lists in the dict returned here won't grow any more,
        which means it can safely be used by another thread.
        The data _in_ the lists (e.g. the contained numpy arrays)
        isn't copied, though.

        TODO full docs
        """
        with self.lock:
            if self.buffers is None:
                return None
            buf_snapshot = {}
            for name, buf in self.buffers.items():
                buf_snapshot[name] = [val for val in self.buffers[name]]
        return buf_snapshot


class PlotListener():
    def __init__(self, port, host='0.0.0.0', len_history=200):
        self.len_history = len_history
        self.accumulator = DataAccumulator(port, host, max_buffer=len_history * 2)
        self.stopped = False
        self.initialized = False

    def start(self):
        self.accum_thread = TracebackThread(target=self.accumulator.run, daemon=True)
        self.accum_thread.start()
        self.start_plot_loop()

    def stop(self):
        self.stopped = True

    def start_plot_loop(self):
        while not self.stopped:
            if self.accumulator.bad_data_change:
                print(self.accumulator.tb_message)
                print('Data format has changed, restart me!\n')
                return

            # Grab the data
            accumulated = self.accumulator.get_copy()
            if accumulated is None:
                time.sleep(0.1)
                continue

            no_data_since = time.perf_counter() - self.accumulator.last_update
            if no_data_since > 3.:
                # if the sender was pausing for a long time, clear the buffer.
                # otherwise, we get a crazy wide time axis once data comes
                # in again.
                print('No data received for a long time, resetting plot')
                self.accumulator.purge()
                continue

            parsed_data = self.prepare_data(**accumulated)
            if not isinstance(parsed_data, tuple):
                parsed_data = (parsed_data,)
            if not self.initialized:
                self.initialize(*parsed_data)
                self.initialized = True
            self.update(*parsed_data)

    def prepare_data(self, data, timestamps, messages, steps):
        """
        Extract whatever this plot needs from the buffer of recent log events.

        Override this for your custom listener type. The outputs of this method
        will be passed to the `initialize` and `update` methods.

        Params
        ---
        data: list of all payloads we recently received (most recent last)
        timestamps: list of `datetime`s when each of the above was logged
        messages: list of string messages from those log calls
        steps: list of the `step` integers if given in the log call

        Returns
        ---
        One or more values of choice
        """
        raise NotImplementedError

    def initialize(self, *parsed_data):
        """
        Do some data-dependent initializations, like setting up certain subplots.

        Override this if needed.
        """
        pass

    def update(self, *parsed_data):
        """
        Do something with the freshest data

        Override this.
        """
        raise NotImplementedError


class MatplotlibListener(PlotListener):
    min_plot_update_interval = 0.066

    def __init__(self, *args, **kwargs):
        self.last_draw = -9000
        super().__init__(*args, **kwargs)

    def create_figure(self, *parsed_data):
        """
        Create a figure based on the data returned by `prepare_data`

        Override this.

        Returns
        ----
        matplotlib Figure
        """
        raise NotImplementedError

    def update_figure(self, figure, *parsed_data):
        """
        Change things in the figure based on the data returned by `prepare_data`

        Override this.
        """
        raise NotImplementedError

    def initialize(self, *parsed_data):
        """ Do matplotlib-specific figure setup. Don't override this. """
        self.figure = self.create_figure(*parsed_data)
        msg = "create_figure must return a Figure instance"
        assert isinstance(self.figure, matplotlib.figure.Figure), msg
        def handle_close(evt):
            print("Stopping plotter.")
            self.stop()
        self.figure.canvas.mpl_connect('close_event', handle_close)
        self.figure.show()  # raises the window, among other things

    def update(self, *parsed_data):
        """ Do a matplotlib-specific plot update dance. Don't override this. """
        self.update_figure(self.figure, *parsed_data)
        self.kick_matplotlib()
        self.wait()
        # (hack: update the accumulator's buffer size, in case
        # the desired history window was changed through the GUI)
        self.accumulator.set_buffersize(2 * self.len_history)

    def kick_matplotlib(self):
        """
        Request that our latest plot commands are actually drawn

        That involves requesting a redraw of the figure and then
        letting the matplotlib event loop breathe at least once
        so all the requested draw commands plus any GUI events are
        processed.
        """
        self.figure.canvas.draw_idle() # takes no time
        self.figure.canvas.start_event_loop(0.001)  # takes ~100ms

    def wait(self):
        """ wait until the plot interval is over """
        time_passed = time.perf_counter() - self.last_draw
        time_left = self.min_plot_update_interval - time_passed
        if time_left > 0.01:
            self.figure.canvas.start_event_loop(time_left - 0.01)
        self.last_draw = time.perf_counter()
        # In general, all the fig.canvas.xxx() calls here are
        # basically an implementation of plt.pause() without the
        # window raising behavior and with more control over
        # the timing (e.g. waiting longer only if time is left).
        # All this nonsense only made sense to me temporarily
        # after reading the source code. So for future reference:
        # https://matplotlib.org/_modules/matplotlib/pyplot.html#pause
        # https://matplotlib.org/_modules/matplotlib/backend_bases.html#FigureCanvasBase.start_event_loop
