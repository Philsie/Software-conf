import os
from tempfile import TemporaryDirectory
import numpy as np
import subprocess as sp
import json

from typing import Generator, Tuple


def save_video(
    frames: np.ndarray,
    out_path: str,
    create_folder: bool = True,
    crf: int = 8,
    fps: int = 15,
) -> None:
    """
    Save a sequence of RGB frames to an h264 encoded video file

    Parameters:
    -----------
    frames : sequence of (H x W x 3) uint8 arrays
        the frames of the video, each with the same height
        and width and a trailing dimension of size 3 (RGB).

    out_path : str
        Output file location. Its suffix will determine
        the video container format - if in doubt use '.mp4'.

    create_folder : bool
        If the parent directory of out_path doesn't exist,
        create it.

    crf : int
        Compression factor, lower numbers mean higher quality.
        Values below 8 make no difference even in direct comparison
        with the source material. Values up to 17 look artifact free
        when viewed on their own, but direct comparison reveals that
        that already loses details. The maximum is apparently 51.
        See https://trac.ffmpeg.org/wiki/Encode/H.264#crf

    fps : int
        Sets the frame rate of the resulting video file. This isn't
        terribly important if all we're doing is load the video frames
        back into numpy arrays, but if you set this correctly the video
        will play at the correct speed even when you open it directly
        in a video player.
        Caveat: This number has a slight side effect on quality because
        the compression factor determines bytes per unit ot time. So if
        you set fps from 10 to 100 but keep crf constant, you will get
        a slightly worse looking video. It's fine for our range of 10-30
        fps though (I picked crf 8 on ffmpeg's default fps, 25).

    Raises:
    -------
    IOError, OSError :
        If the ffmpeg compression fails. The exception message will
        show the exact complaint raised by `ffmpeg` through `stderr`.
        The two exceptions are synonymous, `IOError == OSError`.
    """

    frames = np.array(frames)
    height, width, channels = frames[0].shape
    assert channels == 3, "Video compression expects RGB arrays (shape HxWx3)"
    for frame in frames:
        msg = "Cannot save video with changing frame sizes"
        assert frame.shape == (height, width, channels), msg
        assert frame.dtype == 'uint8', "Video compression expects uint8 array"

    if create_folder:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)

    command = ['ffmpeg',
               # input options:
               '-f', 'rawvideo',      # inputs arrive without file headers
               '-vcodec','rawvideo',  # the input is uncompressed
               '-s', '%sx%s' % (width, height), # the size of each frame
               '-pix_fmt', 'rgb24',  # pixels are 8 bit per channel
               '-framerate', '%d' % fps,  # explain how fast these frames are
               '-i', '-',            # The input comes from a pipe
               # output options:
               '-an',             # no audio
               '-c:v', 'libx264', # use h264 video codec
               '-crf', str(crf),  # compression factor
               '-pix_fmt', 'yuv444p',  # no chroma subsampling!
               out_path]

    ffmpeg = sp.Popen(command, bufsize=-1, stdin=sp.PIPE, stderr=sp.PIPE)

    bytestream = frames.tobytes()
    _, stderr = ffmpeg.communicate(bytestream)

    if ffmpeg.returncode != 0:
        stderr_t = stderr.decode('utf8')
        raise IOError("Error saving video\n"
                      "with call %s:\n\n %s" % (command, stderr_t))


def load_video(path: str) -> np.ndarray:
    """
    Load an mp4 video as a sequence of RGB arrays

    Parameters:
    -----------
    path : str
        The location of a video file.

    Returns:
    --------
    video : np.ndarray of shape (T, H, W, 3) and dtype np.uint8
        A stack of uncompressed video frames in channel-last format.

    Raises:
    -------
    IOError :
        If the ffmpeg decoding fails. The error message will pass on
        the `stderr` output produced by `ffmpeg`. The two exceptions
        are synonymous, `IOError == OSError`.
    """

    command = ['ffmpeg',
               # input options:
               '-i', path,
               # output options:
               '-f', 'image2pipe',
               "-pix_fmt", "rgb24",
               '-vcodec', 'rawvideo',
               '-']

    ffmpeg = sp.Popen(command, bufsize=-1, stdout=sp.PIPE, stderr=sp.PIPE)

    bytestream, stderr = ffmpeg.communicate()
    if ffmpeg.returncode != 0:
        stderr_t = stderr.decode('utf8')
        raise IOError("Error loading video\n"
                      "with call %s:\n\n %s" % (command, stderr_t))

    length, height, width = get_video_size(path)
    channels = 3  # since we requested RGB frames above
    bytes_per_frame = width*height*channels  # since we have 1 byte per channel
    frames = []
    for offset in range(0, len(bytestream), bytes_per_frame):
        frame_bytes = bytestream[offset:offset+bytes_per_frame]
        pixels = np.frombuffer(frame_bytes, dtype='uint8')
        frame = pixels.reshape(height, width, channels)
        frames.append(frame)
    assert len(frames) == length, "Video decoding got wrong number of frames"
    return np.array(frames)


def iter_video(path: str) -> Generator[np.ndarray, None, None]:
    """ Iterate over the frames in a video.
    
    Parameters:
    -----------
    path : str
        A path to a compressed video file.
    
    Yields:
    -------
    frame : array of shape [H, W, D] and dtype `uint8`
        The decompressed images in the video, in sequence.

    Raises:
    -------
    IOError, OSError :
        If either of the following three things happen:

         1. the call to `ffprobe` or the call to `ffmpeg` fails; i this
            case, the exception message will reproduce the full error
            message returned by the call
         2. the `read` call returns a positive number of bytes which
            does not match the number of bytes in a single image
         3. the number of frames yielded by the iteration doesn't match
            the video length postulated in the file header (NOTE: this
            appears to never occur, because the call to `ffprobe` will
            have failed if the file length mismatches the header)
        
        NOTE: the two exceptions are synonymous, `IOError == OSError`.
    """

    command = ['ffmpeg',
               # input options:
               '-i', path,
               # output options:
               '-f', 'image2pipe',
               "-pix_fmt", "rgb24",
               '-vcodec', 'rawvideo',
               # don't log any events that don't spell doom for the
               # process -- that way, we can (in the future) run a
               # parallel process that reads from `ffmpeg.stderr` and
               # stops the data-reading if any error messages appear:
               '-loglevel', 'fatal',
               '-']

    length_in_frames, height, width = get_video_size(path)
    depth = 3  # since we requested RGB frames above
    
    bytes_per_frame = width * height * depth  # since we have 1 byte per channel
    imshape = (height, width, depth)

    with sp.Popen(command, stdout=sp.PIPE) as ffmpeg:
        assert ffmpeg.stdout

        num_yielded = 0

        # the following loop never reads from stderr and therefore never
        # discovers if a decoding error has been passed back to us that
        # way. It will presumably still break (I guess?) because a frame
        # of size 0 has then occurred, but it's not exactly what we're
        # looking for.

        while True:
            frame_bytes = ffmpeg.stdout.read(bytes_per_frame)
            if not frame_bytes:
                break  # `.read` came up empty-handed
            elif len(frame_bytes) == bytes_per_frame:
                yield np.frombuffer(frame_bytes, dtype='uint8').reshape(imshape)
                num_yielded += 1
            else:
                raise IOError('Received %s bytes < 1 frame = %s bytes'
                              % (len(frame_bytes), bytes_per_frame))

    if num_yielded != length_in_frames:  # never happens?
        raise IOError('The number of frames in the video file did not '
                      'match the file header (got %s, expected %s)' %
                      (num_yielded, length_in_frames))


def get_video_size(path: str) -> Tuple[int, int, int]:
    """
    Get the nr of frames and frame shape of a video file

    Parameters:
    -----------
    path : str
        The location of a video file.

    Returns:
    --------
    nframes : int
        The length of the video, in frames.
    height : int
        The height of each image in the video, in pixels.
    width : int
        The width of each image in the video, in pixels.
    
    Raises:
    -------
    IOError, OSError :
        If the call to `ffprobe` fails.
    """

    command = ['ffprobe',  # utility that comes with ffmpeg
               '-v', 'error', # reduce verbosity
               '-show_entries', 'stream', # request (video) stream info
               '-of', 'json', # output something parseable
               path]

    ffprobe = sp.Popen(command, universal_newlines=True, # use strings not bytes
                       stdout=sp.PIPE, stderr=sp.PIPE)

    stdout, stderr = ffprobe.communicate()
    if ffprobe.returncode != 0:
        raise IOError("Error inspecting video\n"
                      "with call %s:\n\n %s" % (command, stderr))

    info = json.loads(stdout)
    stream = info['streams'][0]

    return int(stream['nb_frames']), int(stream['height']), int(stream['width'])

