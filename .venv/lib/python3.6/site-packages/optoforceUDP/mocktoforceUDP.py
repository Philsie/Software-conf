"""
Mock of the optoforce driver
"""
import numpy

__author__ = "arthur"
__date__ = "27.07.2020"

# Questions & Answers:
# how to make this a module?
# 	put it in a folder and a __init__.py
# how to make it so that importing mocktoforceUDP already gives you functions and not the package?
# 	__init__.py should `from .mocktoforceUDP import *`, thus making all functions available.
# should it have a class?
# 	yes, because the driver now has one too.
# what kind of numpy array get_ft_np should return?
# 	6 dimensions
# forces and torques in the nparray?
# 	fx,fy,fz,tx,ty,tz in that order

# The optoforce driver defines the following bindings:
#
# PYBIND11_MODULE(optoforceUDP, m) {
#     py::class_<optoforceUDP> optoforceUDP(m, "optoforceUDP");
#     optoforceUDP.def(py::init<>());
#     optoforceUDP.def("init", &optoforceUDP::init);
#     optoforceUDP.def("deinit", &optoforceUDP::deinit);
#     optoforceUDP.def("get_ft_np", &optoforceUDP::get_ft_np);
#     optoforceUDP.def("get_period", &optoforceUDP::get_period);
#     optoforceUDP.def("ft_zero", &optoforceUDP::ft_zero);
#     optoforceUDP.def("select_onRobot", &optoforceUDP::select_onRobot);
#     optoforceUDP.def("select_ati", &optoforceUDP::select_ati);
#     }


class optoforceUDP:
    def __init__(self):
        self.state = ''
        self.ip_address = ''
        self.period = 0
        self.__count = 0

    def make_some_noise(self) -> numpy.ndarray:
        """
        An attempt at a realistic noise.
        How much noise you get?
            Jaad:
            I can tell from looking at  the FT sensor right now. 
            X,Y= +-.05
            Z= +-.25
            Tx,Ty = +-.003
            Tz = +-.001
        """
        xy_range = 0.05
        z_range = 0.25
        txty_range = 0.003
        tz_range = 0.001

        xy = numpy.random.uniform(-(xy_range), xy_range, 2)
        z = numpy.random.uniform(-(z_range), z_range, 1)
        txty = numpy.random.uniform(-(txty_range), txty_range, 2)
        tz = numpy.random.uniform(-(tz_range), tz_range, 1)
        return numpy.concatenate((xy, z, txty, tz), axis=0)

    def init(self, ip_address: str, period: int) -> bool:
        self.ip_address = ip_address
        self.period = period
        return True

    def deinit(self) -> bool:
        return True

    def get_ft_np(self) -> numpy.ndarray:
        if self.state == 'Zeroing':
            self.state = 'ReadReady'
            return numpy.zeros(6) + self.make_some_noise()

        # assuming x y z rx ry rz, it moves in circles around the z axis without changing
        # orientation
        x = numpy.sin(self.__count)
        y = numpy.cos(self.__count)
        force_torque = numpy.array([x, y, 0., 0., 0., 0.]) * 5
        self.__count += .01

        # machine learning is very picky and it likes it's food noisy
        return force_torque + self.make_some_noise()

    def get_period(self) -> int:
        return self.period

    def ft_zero(self) -> bool:
        self.state = 'Zeroing'
        return True

    def select_onRobot(self) -> None:
        pass

    def select_ati(self) -> None:
        pass
